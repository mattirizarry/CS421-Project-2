# -*- coding: utf-8 -*-
"""CS421.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16XVFSQG1D9h8CZe5c2j80-4bGD7lr0ht
"""

import numpy as np

def almost_equal_color_sequence_from_adjacency_matrix(adj_matrix, k, n):
  # Check if the matrix is a valid adjacency matrix
  if n != len(adj_matrix[0]):
      print("Invalid adjacency matrix.")
      return

  # Initialize the color sequence
  color_sequence = [0] * n

  # Sort nodes by degree (number of connections) in descending order
  nodes_by_degree = sorted(range(n), key=lambda x: np.count_nonzero(adj_matrix[x]), reverse=True)

  # Assign colors greedily
  for node in nodes_by_degree:

    neighbors = []

    for i in range(n):
      if adj_matrix[node][i] == 1:
        neighbors.append(i)

    neighbor_colors_generator = (color_sequence[n] for n in neighbors)
    neighbor_colors = set(neighbor_colors_generator)

    available_colors = set(range(k)) - neighbor_colors

    if available_colors:
        color_sequence[node] = min(available_colors)
    else:
        print("No such a sequence exists.")
        return

  return color_sequence

def print_color_sequence(color_sequence):

  color_sequence_formatted = [0] * k

  for color in color_sequence:
    color_sequence_formatted[color] += 1

  print(color_sequence_formatted)

def display_vertices_by_color(color_sequence):
    color_groups = {}

    for i, color in enumerate(color_sequence):
        if color not in color_groups:
            color_groups[color] = []
        color_groups[color].append(i)

    for color, vertices in color_groups.items():
        print(f"Vertices with color {color}: {vertices}")

import networkx as nx
import matplotlib.pyplot as plt

def visualize_graph(adj_matrix, color_sequence):
    G = nx.Graph()

    # Add nodes to the graph
    G.add_nodes_from(range(len(adj_matrix)))

    # Add edges to the graph based on the adjacency matrix
    for i in range(len(adj_matrix)):
        for j in range(len(adj_matrix[0])):
            if adj_matrix[i][j] == 1:
                G.add_edge(i, j)

    # Create a list of colors for nodes based on the color sequence
    node_colors = [color_sequence[i] for i in range(len(color_sequence))]

    # Draw the graph
    pos = nx.spring_layout(G)  # You can use different layout algorithms
    nx.draw(G, pos, with_labels=True, node_color=node_colors, cmap=plt.cm.rainbow)
    plt.show()

def generate_random_simple_adjacency_matrix(num_nodes, edge_probability):
    # Generate a random adjacency matrix with values of 0 or 1 based on edge_probability
    rand_matrix = np.random.choice([0, 1], size=(num_nodes, num_nodes), p=[1 - edge_probability, edge_probability])

    # Ensure simplicity by removing self-loops and multiple edges
    np.fill_diagonal(rand_matrix, 0)
    rand_matrix = np.triu(rand_matrix) + np.triu(rand_matrix, 1).T

    return rand_matrix

def read_adjacency_matrix_from_file(file_path):
  with open(file_path, 'r') as file:
    k_value = int(file.readline().strip())
    matrix_size = int(file.readline().strip())

    # Initialize the adjacency matrix with zeros
    adj_matrix = [[0] * matrix_size for _ in range(matrix_size)]

    l = 0

    for line in file:
        values = list(map(int, line.strip().split()))
        adj_matrix[l] = values
        l += 1

  return (adj_matrix, k_value, matrix_size)

#=================================================================
# Test Case 1
#=================================================================

adjacency_matrix = [
    [0, 1, 1, 0, 0, 0],
    [1, 0, 1, 1, 0, 0],
    [1, 1, 0, 0, 1, 1],
    [0, 1, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 1],
    [0, 0, 0, 1, 1, 0]
]

# Set the number of colors (k)
k = 3

# Find almost equal color sequence
almost_equal_color_sequence = almost_equal_color_sequence_from_adjacency_matrix(adjacency_matrix, k, 6)

if (almost_equal_color_sequence != None):
  visualize_graph(adjacency_matrix, almost_equal_color_sequence)
  print_color_sequence(almost_equal_color_sequence)
  display_vertices_by_color(almost_equal_color_sequence)

#=================================================================
# End Test Case 1
#=================================================================

#=================================================================
# Test Case 2 (random nodes)
#=================================================================

# Set the number of nodes and density
num_nodes = 25
edge_density = 0.25

# Generate a random adjacency matrix
random_adj_matrix = generate_random_simple_adjacency_matrix(num_nodes, edge_density)

# Set the k value
k = 5

almost_equal_color_sequence = almost_equal_color_sequence_from_adjacency_matrix(random_adj_matrix, k, len(random_adj_matrix[0]))

if (almost_equal_color_sequence != None):
  visualize_graph(random_adj_matrix, almost_equal_color_sequence)
  print_color_sequence(almost_equal_color_sequence)
  display_vertices_by_color(almost_equal_color_sequence)

#=================================================================
# End Test Case 2 (random nodes)
#=================================================================

#=================================================================
# Test Case 3 (reading from a file)
#=================================================================

file_path = 'adjmatrix'

# Read the adjacency matrix from the file
adj_matrix, k, n = read_adjacency_matrix_from_file(file_path)

color_sequence_from_file = almost_equal_color_sequence_from_adjacency_matrix(adj_matrix, k, n)

if (color_sequence_from_file != None):
  visualize_graph(adj_matrix, color_sequence_from_file)
  print_color_sequence(color_sequence_from_file)
  display_vertices_by_color(color_sequence_from_file)

#=================================================================
# End Test Case 3 (reading from a file)
#=================================================================